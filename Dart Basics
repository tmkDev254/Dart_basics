Section 1: Dart Basics - Variables, Data Types & Operators
Dart is a statically typed language, but it also supports type inference, making it feel dynamic at times.

1.1 Variables and Type Inference
Variables: Used to store data. Declared using var, final, const, or explicit type names (int, String, etc.).

var: A flexible way to declare a variable. Dart infers its type based on the initial value. Once inferred, its type cannot change, but its value can.

Dart

var name = 'Alice'; // name is inferred as String
// name = 123; // ERROR: A value of type 'int' can't be assigned to a variable of type 'String'.
name = 'Bob'; // OK


Explicit Type Declaration: You can explicitly specify the type. This is often preferred for clarity, especially in Flutter.

Dart

String message = 'Hello Dart!';
int count = 10;
double price = 9.99;
bool isActive = true;
dynamic: A variable declared as dynamic can hold any type of value, and its type can change at runtime. Use sparingly as it bypasses type safety.

Dart

dynamic anything = 'Hello';
anything = 123;
anything = true;
1.2 final vs. const
These keywords are crucial for immutability and performance in Flutter.

final:

Declares a variable that can be assigned only once.

Its value is determined at runtime.

Once assigned, its value cannot change.

Dart

final String userId = someFunctionThatReturnsUserId(); // Value determined when function runs
final DateTime now = DateTime.now(); // Value determined when code executes
// userId = 'newId'; // ERROR: A final variable 'userId' can only be set once.
const:

Declares a variable that must hold a compile-time constant value.

Its value must be known and fixed before the program runs.

const values are canonicalized/interned: If you create multiple identical const values, they all point to the same object in memory, saving memory and improving performance.

A const variable must be assigned a const value.

Dart

const double PI = 3.14159; // Value known at compile time
const List<int> staticList = [1, 2, 3]; // This list is immutable and created at compile time
// const String runtimeError = DateTime.now().toString(); // ERROR: Not a compile-time constant

// Example of canonicalization:
const String hello = 'Hello';
const String world = 'Hello';
print(identical(hello, world)); // true - they point to the same object
When to use in Flutter:

Use const for widgets and values that never change. This allows Flutter to rebuild only necessary parts of the UI, boosting performance.

Use final for data that is initialized once but whose value isn't known until the app runs (e.g., data fetched from an API).

Use var or explicit types for mutable state within a widget (less common in modern Flutter with state management, but still valid).

1.3 Built-in Data Types
Dart has robust built-in types.

Numbers (num, int, double):

num: An abstract superclass for int and double. Can hold either.

Dart

num countOrPrice = 10;
countOrPrice = 10.5; // OK
int: Whole numbers (integers), up to 64-bit signed.

Dart

int age = 30;
int largeNumber = 9007199254740991; // Max 64-bit int
double: Floating-point (decimal) numbers, 64-bit (double-precision).

Dart

double temperature = 25.5;
double pi = 3.14159;
Note on Division: / always results in a double. ~/ performs integer division (truncates decimals).

Dart

print(10 / 3);  // Output: 3.3333333333333335 (double)
print(10 ~/ 3); // Output: 3 (int)
Strings (String): UTF-16 code units. Use single or double quotes. Multiline strings with triple quotes.

Dart

String singleQuote = 'This is a string.';
String doubleQuote = "This is also a string.";
String multiLine = '''This is a
multi-line string.''';
String interpolation = 'My name is $name and I am ${age} years old.';
Booleans (bool): true or false. Dart is type-safe; if (0) is an error.

Dart

bool isLoggedIn = false;
if (isLoggedIn) {
  print('Welcome back!');
}
Lists (List<Type>): Ordered collections of objects. Similar to arrays.

Dart

List<String> fruits = ['apple', 'banana', 'orange'];
List<int> numbers = [1, 2, 3];
fruits.add('grape');
print(fruits[0]); // Output: apple
Growable by default: List.filled(3, 'a', growable: false) creates a fixed-length list.

Spread operator (... and ...?): For inserting all elements of a list into another list.

Dart

List<int> moreNumbers = [4, 5, 6];
List<int> allNumbers = [...numbers, ...moreNumbers]; // [1, 2, 3, 4, 5, 6]
List<int>? nullableList;
List<int> safeList = [10, ...?nullableList, 20]; // Safely includes elements if nullableList is not null
Collection if and for: For conditionally including elements or building elements programmatically.

Dart

bool showExtra = true;
List<String> shoppingList = [
  'Milk',
  'Bread',
  if (showExtra) 'Eggs', // 'Eggs' is included if showExtra is true
  for (var i = 0; i < 3; i++) 'Item $i' // Adds 'Item 0', 'Item 1', 'Item 2'
];
Sets (Set<Type>): Unordered collections of unique objects.

Dart

Set<int> uniqueNumbers = {1, 2, 2, 3}; // {1, 2, 3}
uniqueNumbers.add(4);
print(uniqueNumbers.contains(2)); // true
Maps (Map<KeyType, ValueType>): Key-value pairs. Similar to dictionaries or hash tables.

Dart

Map<String, int> ages = {'Alice': 30, 'Bob': 25};
print(ages['Alice']); // Output: 30
ages['Charlie'] = 35;
Runes: Unicode code points in a string. Used for manipulating emojis or special characters. (Less common in daily Flutter dev).

Symbols: Opaque, immutable identifiers for Dart declarations. (Less common in daily Flutter dev).

1.4 Operators
Dart supports standard operators.

Arithmetic: +, -, *, /, ~/ (integer division), % (modulo).

Equality & Relational: ==, !=, >, <, >=, <=.

Type Test: is (type check), is! (not type check), as (type cast).

Dart

dynamic obj = 'Hello';
if (obj is String) {
  print('It\'s a string!');
}
String str = obj as String; // Casts obj to String
Assignment: =, +=, -=, *=, /=, etc.

??= (assign if null): Assigns a value only if the variable is currently null.

Dart

int? value;
value ??= 10; // value is now 10
value ??= 20; // value is still 10 (not null, so assignment skipped)
Logical: && (AND), || (OR), ! (NOT).

Null-aware Operators:

?. (null-aware access): Access a property or method only if the object is not null.

Dart

String? nullableString;
print(nullableString?.length); // Output: null (no error)
nullableString = 'Dart';
print(nullableString?.length); // Output: 4
?? (null coalescing): Returns the first non-null expression.

Dart

String? name;
String displayName = name ?? 'Guest'; // displayName is 'Guest'
name = 'Alice';
displayName = name ?? 'Guest'; // displayName is 'Alice'
! (null assertion operator): Asserts that an expression is non-null. Use with caution, as it throws an error if the value is actually null.

Dart

String? nonNullString = 'Hello';
String assertedString = nonNullString!; // Asserts nonNullString is not null
// String? potentiallyNull;
// String errorString = potentiallyNull!; // ERROR if potentiallyNull is null
Conditional (Ternary): condition ? expr1 : expr2.

Dart

int age = 18;
String status = age >= 18 ? 'Adult' : 'Minor'; // status is 'Adult'
Cascade Notation (..): Allows you to perform a sequence of operations on the same object.

Dart

var buffer = StringBuffer()
  ..write('Hello')
  ..write(' ')
  ..writeln('Dart!'); // returns buffer
print(buffer.toString()); // Output: Hello Dart!


//Comprehensive example using Flutter

// 1. Import the Flutter Material library.
// This line gives us access to all the pre-built widgets
// that follow Google's Material Design principles.
import 'package:flutter/material.dart';

// The main function is the entry point of every Flutter app.
// It's the first thing that gets executed.
void main() {
  // `runApp` is the core function that takes a widget and makes it the
  // root of the widget tree, which then gets rendered on the screen.
  // We use `const` here as a performance optimization, telling Flutter that
  // this widget and its children will not change at runtime.
  runApp(const MyFlutterApp());
}

// 2. This is the root widget of our application.
// We use a StatelessWidget because its properties (like `appTitle`)
// don't change after it's created.
class MyFlutterApp extends StatelessWidget {
  // The constructor uses the `super.key` shorthand. This is a modern,
  // concise way to pass the widget's unique `key` identifier to its parent class.
  const MyFlutterApp({super.key});

  // The `build` method describes the UI that this widget represents.
  // It's called by the Flutter framework to render the widget on the screen.
  @override
  Widget build(BuildContext context) {
    // 1.3 Built-in Data Types: We declare some simple variables.
    // Dart infers the type of `appTitle` as `String`.
    var appTitle = 'Dart & Flutter Fundamentals';
    // We explicitly declare `paddingValue` as a `double`.
    double paddingValue = 16.0;

    // `MaterialApp` is the core of a Material Design app. It provides a lot of
    // app-wide functionality like theming, navigation, and titles.
    return MaterialApp(
      // 1.2 `const` for widget trees that don't change. We don't use it directly here
      // because `appTitle` is a variable.
      // The `title` property is used for the app's name in the OS, like in the
      // list of recent apps on Android or the browser tab on the web.
      title: appTitle,
      // `Scaffold` provides the basic visual layout for a single screen.
      // It includes space for a header (`appBar`), body, and other elements.
      home: Scaffold(
        // The `AppBar` widget is the header at the top of the screen.
        appBar: AppBar(
          // The `title` property of the `AppBar` displays the text on the screen.
          // It's a `Text` widget, whose content is the `appTitle` variable.
          title: Text(appTitle),
        ),
        // The `body` of the `Scaffold` is the main content area below the AppBar.
        // We are passing a custom `MyDataDisplay` widget here.
        body: MyDataDisplay(
          // 1.1 Variable & Type Inference: We pass our `paddingValue` variable
          // to the `padding` property of our custom widget.
          padding: paddingValue,
        ),
      ),
    );
  }
}

// 2. A StatefulWidget to manage dynamic data and state.
// This is the widget that will display changing information.
class MyDataDisplay extends StatefulWidget {
  // `final` variable to hold immutable data passed to the widget.
  // The `padding` value is received from the parent and cannot be changed here.
  final double padding;

  // The constructor requires the `padding` value to be provided.
  const MyDataDisplay({super.key, required this.padding});

  // The framework calls this to create the mutable State object.
  // The State object holds all the data that can change over time.
  @override
  State<MyDataDisplay> createState() => _MyDataDisplayState();
}

// The State class where the mutable data and logic live.
// The underscore `_` at the start makes this class private to this file.
class _MyDataDisplayState extends State<MyDataDisplay> {
  // 1.2 `late final` and `final` for variables initialized only once.
  // `late final` is a promise that `_apiEndpoint` will be initialized before its first use.
  late final String _apiEndpoint;
  // A `dynamic` variable to show its flexibility (use sparingly).
  // Its type can change at runtime.
  dynamic _dataFromApi;

  // 1.3 Built-in Data Types: Boolean for conditional logic.
  // We use `_isLoading` to track when our "network request" is running.
  bool _isLoading = true;
  bool _isLoggedIn = true;

  // `initState` is a lifecycle method called once when this widget is first created.
  // It's the perfect place to perform one-time setup, like a network call.
  @override
  void initState() {
    super.initState();
    // 1.2 `late final` variable is initialized here, fulfilling our promise.
    _apiEndpoint = 'https://api.example.com/data';
    
    // We use `Future.delayed` to simulate a network request that takes 2 seconds.
    Future.delayed(const Duration(seconds: 2), () {
      // `setState` is crucial! It tells Flutter to rebuild the widget
      // and update the UI to reflect our new data.
      setState(() {
        // Here, we update our `dynamic` variable with the simulated data.
        _dataFromApi = {'name': 'Alice', 'score': 95};
        _isLoading = false;
      });
    });
  }

  // The `build` method is called every time the widget's state changes.
  // It describes what the UI should look like based on the current state.
  @override
  Widget build(BuildContext context) {
    // 1.1 Variables and Type Inference: The type of `headerWidgets` is inferred as `List<Widget>`.
    var headerWidgets = [
      const Text('User Data', style: TextStyle(fontSize: 20)),
      const Divider(),
    ];
    
    // 1.3 Built-in Data Types: A `const` list of strings for our product names.
    const List<String> productNames = ['Laptop', 'Mouse', 'Keyboard', 'Monitor'];

    // `SingleChildScrollView` allows the content to be scrollable if it's too long.
    return SingleChildScrollView(
      child: Padding(
        padding: EdgeInsets.all(widget.padding),
        child: Column(
          // `crossAxisAlignment` aligns the children to the start of the column (left side).
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 1.3 Spread Operator (`...`): This operator unpacks the items from a list
            // and inserts them directly into this list of widgets.
            ...headerWidgets,
            
            // 1.4 Conditional (Ternary) Operator: A concise way to choose one widget or another.
            // If `_isLoading` is true, show the spinner. Otherwise, show the user data.
            _isLoading
                ? const Center(child: CircularProgressIndicator())
                :
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // 1.4 Null-aware Operators (`??`, `?.`): Safely handle a null value.
                    // `_dataFromApi?.['name']`: The `?.` safely checks if `_dataFromApi` is null
                    // before trying to access the `'name'` property.
                    // `?? 'N/A'`: The `??` operator provides a fallback value ('N/A')
                    // if the result of the previous expression is null.
                    Text(
                      'Name: ${_dataFromApi?['name'] ?? 'N/A'}',
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                    // 1.3 String Interpolation
                    Text(
                      'Score: ${_dataFromApi?['score'] ?? 'N/A'}',
                    ),
                  ],
                ),
            
            // `SizedBox` is a simple widget for creating space.
            const SizedBox(height: 20),
            const Text('Product List', style: TextStyle(fontSize: 20)),
            const Divider(),
            
            // 1.3 Collection `for` & `if`: Dynamically build a list of widgets.
            // We use the spread operator on a list created on the fly.
            ...[
              // The `for` loop dynamically generates a list of `Container` widgets.
              for (int i = 0; i < productNames.length; i++)
                Container(
                  padding: const EdgeInsets.all(8),
                  margin: const EdgeInsets.only(bottom: 8),
                  decoration: BoxDecoration(
                    color: Colors.grey[200],
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    children: [
                      // 1.3 String Interpolation: We embed a variable into a string.
                      Text('${i + 1}. ${productNames[i]}'),
                      // `Spacer` takes up all available space between widgets.
                      const Spacer(),
                      // 1.3 `if` statement for conditional rendering inside a collection.
                      // The `Icon` widget is only included in the list if `_isLoggedIn` is true.
                      if (_isLoggedIn)
                        const Icon(Icons.shopping_cart, color: Colors.blue),
                    ],
                  ),
                ),
            ]
          ],
        ),
      ),
    );
  }
}

