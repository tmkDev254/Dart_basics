Section 1: Dart Basics - Variables, Data Types & Operators
Dart is a statically typed language, but it also supports type inference, making it feel dynamic at times.

1.1 Variables and Type Inference
Variables: Used to store data. Declared using var, final, const, or explicit type names (int, String, etc.).

var: A flexible way to declare a variable. Dart infers its type based on the initial value. Once inferred, its type cannot change, but its value can.

Dart

var name = 'Alice'; // name is inferred as String
// name = 123; // ERROR: A value of type 'int' can't be assigned to a variable of type 'String'.
name = 'Bob'; // OK


Explicit Type Declaration: You can explicitly specify the type. This is often preferred for clarity, especially in Flutter.

Dart

String message = 'Hello Dart!';
int count = 10;
double price = 9.99;
bool isActive = true;
dynamic: A variable declared as dynamic can hold any type of value, and its type can change at runtime. Use sparingly as it bypasses type safety.

Dart

dynamic anything = 'Hello';
anything = 123;
anything = true;
1.2 final vs. const
These keywords are crucial for immutability and performance in Flutter.

final:

Declares a variable that can be assigned only once.

Its value is determined at runtime.

Once assigned, its value cannot change.

Dart

final String userId = someFunctionThatReturnsUserId(); // Value determined when function runs
final DateTime now = DateTime.now(); // Value determined when code executes
// userId = 'newId'; // ERROR: A final variable 'userId' can only be set once.
const:

Declares a variable that must hold a compile-time constant value.

Its value must be known and fixed before the program runs.

const values are canonicalized/interned: If you create multiple identical const values, they all point to the same object in memory, saving memory and improving performance.

A const variable must be assigned a const value.

Dart

const double PI = 3.14159; // Value known at compile time
const List<int> staticList = [1, 2, 3]; // This list is immutable and created at compile time
// const String runtimeError = DateTime.now().toString(); // ERROR: Not a compile-time constant

// Example of canonicalization:
const String hello = 'Hello';
const String world = 'Hello';
print(identical(hello, world)); // true - they point to the same object
When to use in Flutter:

Use const for widgets and values that never change. This allows Flutter to rebuild only necessary parts of the UI, boosting performance.

Use final for data that is initialized once but whose value isn't known until the app runs (e.g., data fetched from an API).

Use var or explicit types for mutable state within a widget (less common in modern Flutter with state management, but still valid).

1.3 Built-in Data Types
Dart has robust built-in types.

Numbers (num, int, double):

num: An abstract superclass for int and double. Can hold either.

Dart

num countOrPrice = 10;
countOrPrice = 10.5; // OK
int: Whole numbers (integers), up to 64-bit signed.

Dart

int age = 30;
int largeNumber = 9007199254740991; // Max 64-bit int
double: Floating-point (decimal) numbers, 64-bit (double-precision).

Dart

double temperature = 25.5;
double pi = 3.14159;
Note on Division: / always results in a double. ~/ performs integer division (truncates decimals).

Dart

print(10 / 3);  // Output: 3.3333333333333335 (double)
print(10 ~/ 3); // Output: 3 (int)
Strings (String): UTF-16 code units. Use single or double quotes. Multiline strings with triple quotes.

Dart

String singleQuote = 'This is a string.';
String doubleQuote = "This is also a string.";
String multiLine = '''This is a
multi-line string.''';
String interpolation = 'My name is $name and I am ${age} years old.';
Booleans (bool): true or false. Dart is type-safe; if (0) is an error.

Dart

bool isLoggedIn = false;
if (isLoggedIn) {
  print('Welcome back!');
}
Lists (List<Type>): Ordered collections of objects. Similar to arrays.

Dart

List<String> fruits = ['apple', 'banana', 'orange'];
List<int> numbers = [1, 2, 3];
fruits.add('grape');
print(fruits[0]); // Output: apple
Growable by default: List.filled(3, 'a', growable: false) creates a fixed-length list.

Spread operator (... and ...?): For inserting all elements of a list into another list.

Dart

List<int> moreNumbers = [4, 5, 6];
List<int> allNumbers = [...numbers, ...moreNumbers]; // [1, 2, 3, 4, 5, 6]
List<int>? nullableList;
List<int> safeList = [10, ...?nullableList, 20]; // Safely includes elements if nullableList is not null
Collection if and for: For conditionally including elements or building elements programmatically.

Dart

bool showExtra = true;
List<String> shoppingList = [
  'Milk',
  'Bread',
  if (showExtra) 'Eggs', // 'Eggs' is included if showExtra is true
  for (var i = 0; i < 3; i++) 'Item $i' // Adds 'Item 0', 'Item 1', 'Item 2'
];
Sets (Set<Type>): Unordered collections of unique objects.

Dart

Set<int> uniqueNumbers = {1, 2, 2, 3}; // {1, 2, 3}
uniqueNumbers.add(4);
print(uniqueNumbers.contains(2)); // true
Maps (Map<KeyType, ValueType>): Key-value pairs. Similar to dictionaries or hash tables.

Dart

Map<String, int> ages = {'Alice': 30, 'Bob': 25};
print(ages['Alice']); // Output: 30
ages['Charlie'] = 35;
Runes: Unicode code points in a string. Used for manipulating emojis or special characters. (Less common in daily Flutter dev).

Symbols: Opaque, immutable identifiers for Dart declarations. (Less common in daily Flutter dev).

1.4 Operators
Dart supports standard operators.

Arithmetic: +, -, *, /, ~/ (integer division), % (modulo).

Equality & Relational: ==, !=, >, <, >=, <=.

Type Test: is (type check), is! (not type check), as (type cast).

Dart

dynamic obj = 'Hello';
if (obj is String) {
  print('It\'s a string!');
}
String str = obj as String; // Casts obj to String
Assignment: =, +=, -=, *=, /=, etc.

??= (assign if null): Assigns a value only if the variable is currently null.

Dart

int? value;
value ??= 10; // value is now 10
value ??= 20; // value is still 10 (not null, so assignment skipped)
Logical: && (AND), || (OR), ! (NOT).

Null-aware Operators:

?. (null-aware access): Access a property or method only if the object is not null.

Dart

String? nullableString;
print(nullableString?.length); // Output: null (no error)
nullableString = 'Dart';
print(nullableString?.length); // Output: 4
?? (null coalescing): Returns the first non-null expression.

Dart

String? name;
String displayName = name ?? 'Guest'; // displayName is 'Guest'
name = 'Alice';
displayName = name ?? 'Guest'; // displayName is 'Alice'
! (null assertion operator): Asserts that an expression is non-null. Use with caution, as it throws an error if the value is actually null.

Dart

String? nonNullString = 'Hello';
String assertedString = nonNullString!; // Asserts nonNullString is not null
// String? potentiallyNull;
// String errorString = potentiallyNull!; // ERROR if potentiallyNull is null
Conditional (Ternary): condition ? expr1 : expr2.

Dart

int age = 18;
String status = age >= 18 ? 'Adult' : 'Minor'; // status is 'Adult'
Cascade Notation (..): Allows you to perform a sequence of operations on the same object.

Dart

var buffer = StringBuffer()
  ..write('Hello')
  ..write(' ')
  ..writeln('Dart!'); // returns buffer
print(buffer.toString()); // Output: Hello Dart!
